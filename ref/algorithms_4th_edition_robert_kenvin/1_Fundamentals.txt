Fundamentals

The objective of this book is to study a broad variety of important and useful
algorithms--methods for solving problems that are suited for computer implementation.
Algorithms go hand in hand with data structure--schemes for organizing data
that leave amenable to efficient processing by an algorithm. This
chapter introduces the basic tools that we need to study algorithms and data structures.

First, we intriduce our basic programming model. All of our programs are implemented 
using a small subset of the Java programming language plus a few of our own
libraries for input/output and for statistical calculations. SECTION 1.1 is summary of
language constructs, features, and libraries that we use in this book.

Next, we emphasize data abstraction, where we define abstract data types (ADTs) in
the service of modular programming. In SECTION 1.2 we introduce the process of 
implementing an ADT in Java, by specifying an applications programming interface (API)
and then using the Java class mechanism to develop an implementation for use in client
code.

As important and useful examples, we next consider three fundamental ADTs: the 
bag, the queue, and the stack. SECTION 1.3 describes APIs and implementations of bags,
queues, and stacks using arrays, resiziing arrays, and linked lists that serve as models and
starting points for algorithm implementations throughout the book.

Performance is a central consideration in the study of algorithms. SECTION 1.4 describes
our approach to analyzing algorithm performance. The basis of our approach is
the scientific mehtod: we develop hypotheses about performance, create mathematical
models, and run experiments to test them, repeating the process as necessary.

We conclude with a case study where we consider solutions to a connectivity problem
that uses algorithms and data structures that implement the classic union-find ADT.


Algorithms 

When we write a computer program, we are generally implementing a
method that has been devised previously to solve some problem. This method is often
independent of the particular programming language being used--it is likely to be
equally appropriate for many computers and many programming languages. It is the
method, rather than the computer program itself, that specifies the steps that we can
thake to solve the problem. The term algorithm is used in computer science to describe
a finite, deterministic, and effective problem-solving method suitable for implementation
as a computer program. Algorithms are the stuff of computer science: they are
central objects of study in the field.

We can define an algorithms by describing a procedure for solving a problem in a
natural language, or by writing a computer program that implements the procedure,
as shown at right for Euclid's algorithm for finding the greatest common divisor of
two numbers, a viriant of which was devised over 2,300 years ago. If you are not familiar
with Euclid's algorithm, you are encouraged to work EXERCISE 1.2.24 and EXERCISE 
1.1.25, perhaps after reading SECTION 1.1. In this book, we use computer programs to 
describe algorithms. One important reason for doing so is that it makes easier the task of
checking whether they are finite, deterministic, and effective, as required. But it is also
important to recognize that a program in a particular language is just one way to express
an algorithm. The fact that many of the algorithms in this book have been expressed 
in multiple programming languages over the past serveal decades reinforces the idea that
each algorithm is a method suitable for implementation on any computer in any programming
language.

  Computer the greatest common divisor of two nonnegative integers p and q as follows:
  if q is 0, the answer is p. If not, divide p by q
  and take the remainder r. The answer is the 
  greatest common divisor of q and r.

  public static int gcd(int p, int q) 		def gcd(p, q):
  {						    if (q == 0):
      if (q == 0) return p;			        return p
      int r = p % q;				    r = p % q
      return gcd(q, r);				    return gcd(q, r)
  } // greatest common divisor			# greatest common divisor

Most algorithms of interest involve organizing the data involved in the computation.
Such organization leads to data structures, which also central objects of study 
int computer science. Algorithms and data structures go hand in hand. In this book we
take the view the data structures exist as the byproducts or end products of algorithms
and that we must therefore study them in order to understand the algorithms. Simple
algorithms can give rise to complicated data structures and, conversely, complicated
algorithms can use simple data structures. We shall study the properties of many data
structures in this book; indeed, we might well have titled the book Algorithms and Data
Structures.

When we use a computer to help us solve a problem, we typically are faced with a 
number of possible approaches. For samll problems, it hardly matters which approach
we use, as long as we have one that correctly solves the problem. For huge problems (or
applications where we need to solve huge numbers of small problems), however, we
quickly become motivated to devise methods that use time and space efficiently.

The primary reason to learn about algorithms is that this discipline gives us the 
potential to reap huge savings, even to the point of enabling us to do tasks that would
otherwise be impossible. In an application where we are processing millions of objects,
it is not unusual to be able to make a program millions of times faster by using a well
designed algorithm. We shall see such examples on numerous occasions throughout
the book. By contrast, investing additional meney or time to buy and install a new
computer holds the potential for speeding up a program by perhaps a factor of only 
10 or 100. Careful algorithm design is an extremely effective part of the process of solving
a huge problem, whatever the applications area.

When developing a huge or complex computer program, a great deal of effort must
go into understanding and defining the problem to be solved, managing its complexity,
and decomposing it into smaller subtasks that can be implemented easily. Often,
many of the algorithms required after the decomposition are trivial to implement. In
most cases, however, there are a few algorithms whose choice is critical because most
of the system resources will be spent running those algorithms. These are the types of
algorithms on which we concentrate in this book. We study fundamental algorithms
that are useful for solving challenging problems in a broad variety of applications areas.

The sharing of programs in computer systems is becoming more widespread, so
although we might expect to be using a large fraction of the algorithms in this book, we
also might expect to have to implement only a small fraction of them. For example, the 
Java Libraries contain implementations of a host of fundamental algorithms. However,
implementing simple versions of basic algoriths helps us to understnad them better
and thus to more effectively use and tune advanced versions from a library. More
important, the opportunity to reimplement basic algorithms arises frequently. The 
primary reason to do so is that we are faced, all too often, with completely new computing
environments (hardware and software) with new features that old implementations
may not use to best advantage. In this book, we concentrate on the simplest reasonable 
implementations of the best algorithms. We do pay careful attention to coding the critical
parts of the algorithms, and take pains to note where low-level optimization effort
could be most beneficial.

The choice of the best algorithms for a particular task can be a complicated process,
perhaps involving sophisticated mathematical analysis. The branch of computer science
that comprises the study of such questions is called analysis of algorithms. Many
of the algorithms that we study have been shown through analysis to have excellent 
theoretical performance; others are simply known to work well through experience. 
Our primary goal is to learn reasonable algorithms for important tasks, yet we shall also
pay careful attention to comparative performance of the methods. We should not use
an algorithms without having an idea of what resources it might consume, so we strive
to be aware of how our algorithms might be expected to perform.


Summary of topics

As an overview, we describe the major parts of the book, giveing specific
topics covered and an indication of our general orientation toward the material.
This set of tipics is intended to touch on as many fundamental algorithms as possible.
Some of the areas covered are core computer-science areas that we study in depth to
learn basic algorithms of wide applicability. Other algorithms that we discuss are from
advanced fields of study within computer science and related fields. The algorithms that
we consider are the products of decades of research and developement and continue to play
an essential role in the ever-expanding applications of computation.


Fundamentals 

(CHAPTER 1) in the context of this book are the basic priciples and methodology that we
use to implement, analyze, and compare algorithms. We consider our Java programming model,
data abstraction, basic data structures, abstract data type for collections, methods of
analyzing algorithm performance, and a case study.


Sorting Algorithms

(CHAPTER 2) for rearranging arrays in order are of fundamental importance. We consider a 
variety of algorithms in considerable depth, including insertion sort, selection sort,
shellsort, mergesort, and heapsort. We also encounter algorithms for several related 
problems, including priority queues, selection, merging. Many of these algorithms will
find application as the basis for other algorithms later in the book.


Searching Alorithms 

(CHAPTER 3) for finding specific items among large collections of items are also of 
fundamental importance. We discuss basic and advanced methods for searching, including
binary search trees, balanced search tree, and hashing. We not relationships among
these methods and compare performance.


Graphs

(CHAPTER 4) are sets of objects and connections, possibly with weights and orientation.
Graphs are useful models for a vast number of difficult and important problems, and
the design of algorithms for processing graphs is a major field of study. We consider
depth-first search, breadth-first search, connectivity problems, and several algorithms
and applications, including Kruskal's and Prim's algorithms for finding minimum spanning
tree and Dijkstra's and the Bellman-Ford algorithms for solving shortest-paths problems.


Strings

(CHAPTER 5) are an essential data type in modern computing applications. We consider a 
range of methods for processing sequences of characters. We begin with faster algorithms
for sorting and searching when keys are strings. Then we consider substring search,
regular expression pattern matching, and data-compression algorithms. Again, an introduction
to advanced topics is given through treatment of some elementary problems that are 
important in their own right.


Context

(CHAPTER 6) helps us relate the material in the book to several other advanced fields of
study, including scientific computing, operations research, and the theory of computing.
We survey event-based simulation, B-trees, suffix arrays, maximum flow, and other 
advanced topics from an introductory viewpoint to develop appreciation for the interesting
advanced fields of study where algorithms play a critical role. Finally, we describe 
search problems, reduction, and NP-completeness to introduce the theoretical underpinnings
of the study of algorithms and relationships to material in this book.


THE STUDY OF ALGORITHMS IS INTERESTING AND EXCITING because it is a new field 
(almost all the algorithms that we study are less than 50 years old, and some were just
recently discovered) with a rich tradition (a few algorithms have been known for 
hundreds of years). New discoveries are constantly being made, but few algorithms are
completely understood. In this book we shall consider intricate, complicated, and 
difficult algorithms as well as elegant, simple, and easy ones. Our challenge is to understand
the former and to appreciate the latter in the context of scientific and commercial 
applications. In doing so, we shall explore a variety of useful tools and develop a style of
algorithmic thinking that will serve use well in computational challenges to come.

