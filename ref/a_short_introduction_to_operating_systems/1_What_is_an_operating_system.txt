Chapter1

What is an operating system?

An operating system is a layer of software which takes care of technical aspects
of a computer's operation. It shields the user of the machine from the low-level
details of the machines's operation and provides frequently needed facilities.
There is no universal definition of what an operating system consists of. You can
think of it as being the software which is already installed on a machine, before
you add anything of your own. Normally the operating system has a number of 
key elements: (i) a technical layer of software for driving the hardware of the
computer, like disk drivers, the keyboard and the screen; (ii) a filesystem which
provides a way of organizing files logically, and (iii) a simple command language
which enables users to run their own programs and to manipulate their files in
a simple way. Some operating systems also provide text editors, compilers,
debuggers and a viarety of other tools. Since the operating system (OS) is in
charger of a computer, all requests to use its resources and devices need to go
through the OS. An OS therefore provides (iv) legal entry points into its code
for performing basic operations like writing to devices.

Operating systems may be classified by both how many tasks they can perform
'simultaneously' and by how many users can be using the system 'simultaneously'.
That is: single-user or multi-user and single-task or multi-tasking. A
multi-user system must clearly be multi-tasking.

Unix is arguably the most important operating system today, and one which
we shall frequently refer to below. It comes in many forms, developed by different
manufactures. Originally designed at AT&T, UNIX split into two camps
early on: BSD (Berkeley software distribution) and system 5 (AT&T license).
The BSD version was developed as a research project at the university of Berkeley,
Califormia. Many of the networking and user-friendly features originate
from these modifications. With time these two versions has been merged back
together and most systems are now a mixture of both worlds. Historically BSD
Unix has been most prevalent in universities, while system 5 has been dominant
in business environments. The trend during the last three years by Sun
Microsystems and Hewlett-Packard amongst others has been to move towards
system 5, keeping only the most important features of the BSD system. A 
standardization committee for Unix called POSIX, formed by the major vendors,
attempts to bring compatibility to the Unix world. 


1.1 Key concepts

Before discussing more of the details, let's review some key ideas which lie
behind the whole OS idea. Although these ideas may seem simple, you will do
well to keep them in mind later. Simple ideas often get lost amongst distracting
details, but it is important to remember that the ideas are simple.


1.1.1 Hierarchies and black boxes

A hierarchy is a way of organizing information using levels of detail. The phrase
high-level implies few details, whereas low-level implies a lot of detail, down in
the guts of things. A hierarchy usually has the form of a tree, which branches
from the highest level to the lowest, since each high-level object is composed 
of several lower-level objects. The key to making large computer programs
and to solving difficult problems is to create a hierarchical structure, in which
large high-level problems are gradually broken up into manageable low-level
problems. Each level works by using a series of 'black boxes' (e.g. subroutines)
whose inner details are not directly visible. This allows us to hide details and 
remain sane as the complexity builds up.

This is the single most important concept in coputing! It is used repeatedly
to organize complex problems.


1.1.2 Resources and sharing

A computer is not just a box which adds numbers together. It has resources 
like the keyboard and the screen, the disk drives and the memory. In a multi-tasking
system there may be several programs which need to receive input
or write output simultaneously and thus the operating system may have to
share these resources between several running programs. If the system has
two keyboards (or terminals) conneccted to it, then the OS can allocate both
to different programs. If only a single keyboard is connected then competing
programs must wait for the resources to become free.

Most multi-tasking systems have only a single central processor unit and yet
this is the most precious resource a omputer has. An multi-tasking operating 
system must therefore share cpu-time between programs. That is, it must work
for a time on one program, then work a while on the next program, and so on.
If the first program was left nfinished, it must then return to work more on
that, in a systematic way. The way an OS decides to share its time between 
different tasks is called scheduling.


1.1.3 Communication, protocols, data types

The exchange of information is an essential part of computing. Suppose computer
A sends a message to computer B reporting on the names of all the users
and how long they have been working. To do this it sends a stream of bits
across a network. When computer B receives a stream of bits, it doesn't 
automatically know what they mean. It must decide if the bits represent numbers
or characters, integers or floating point numbers, or a mixture of all of them.
These different types of data are all stored as binary information - the only
difference between them is the way one chooses to interpret them.

The resolution to this problem is to define a protocol. This is a convention
or agreement between the operating systems of two machines on what messages
may contain. The agreement may say, for instance, that the first thirty-two bits
are four integers which give the address of the machine which sent the message.
The next thirty-two bits are a special number telling the OS which protocol to
use in order to interpret the data. The OS can then look up this protocol and
discover that the rest of the data are arranged according to a pattern of
 
<name><time><name><time>...

Where the name is a string of bytes, terminated by a zero, and the time is a 
four byte digit containing the time in hours. Computer B now knows enough
to be able to extract the information from the stream of bits.

It is important to understand that all computers have to agree on the way 
in which the data are sent in advance. If the wrong protocol is diagnosed, then
a string of characters could easily be converted into a floating point number - 
but the result would have been nonsense. Similarly, if computer A had sent the
information incorrectly, computer B might not be able to read the data and a
protocol error would arise.

  More generally, a protocol is an agreed sequence of behavior 
  which must be followed.

For example, when passing parameters to functions in a computer program,
there are rules about how the parameter should be declared and in which order
they are sent. This is a simple example of a protocol. Protocols are an important
part of communication and data typing and they will appear in many forms
during our discussion of operating systems.


1.1.4 System overhead

An operating system is itself a computer program which must be executed. It
therefore requires its own share of a computer's resources. This is especially
true on multitasking systems, such as UNIX, where the OS is running all the
time along side user's programs. Since user programs have to wait for the OS to
perform certain services, such as allocating resources, they are slowed down by 
the OS. The time spent by the OS servicing user requests is called the system
overhead. On a multi-user system one would like this overhead to be kept to a
minimum, since programs which make many requests of the OS slow not only
themselves down, but all other programs which are queuing up for resources.

In the UNIX C-shell (csh) environment, it is possible to find out the exact
fraction of time spent by the OS working on a program's behalf by using the 
time function.


1.1.5 Caching

Caching is a technique used to speed up communication with slow devices.
Usually the CPU can read data much faster from memory than it can from
a disk or network connection, so it would like to keep an up-to-date copy of
frequently used information in memory. The memory area used to do this is
called a cache. You can think of the whole of the primary memory as being a
cache for the secondary memory (disk).

Sometimes caching is used more generally to mean 'keeping a local copy of
data for convenience'.


1.2 Hardware

Here are list the main hardware concepts.


1.2.1 The CPU

The CPU, or central processor unit is the heart and soul of every computer. This
is the part which does the work of executing machine instructions. Traditionally,
it is just one microprocessor with lots of pins to connect is to memory and
devices - usually identifiable by being the largest chip. On modern machines,
there may be several CPUs which can work in parallel. Also VLSI or very large
scale integration technology has made it possible to put very many separate
processors and memory into a single package, so the physical distinction between
the CPU and its support chips is getting blurred. Nevertheless, the CPU is still
logically separate from th memory and devices.

The CPU is deiven by a 'clock' or pulse generator. Each instruction completes in
a certain number of 'clock cycles'. Traditionally CPUs are based on CISC
(Complex Instruction Set Computing) architecture, where a single instruction
takes one or more clock cycles to complete. A new trend is to build RISC
(Reduced Instruction Set Computing) processors which aim to be more efficient
for a subset of instructions by using redundancy. There have simpler
instructions but can execute much more quickly, sometimes with several
instructions per clock cycle.


1.2.2 Memory

The primary memory is the most important resource a computer has. Since
CPUs are only made with instructions for reading and writing to memory, no
programs would be able to run without it. There are two types of memory:
RAM - random access memory, or read/write memory, which loses its contents
when the machine is switched off, and ROM - read only memory, which never
loses its contents unles destroyed. ROM is normally used for storing those
must fundamental parts of the operating system which are required the instant
a computer is switched on, before it knows about disks etc.


1.2.3 Devices

The concepts of a device really has two parts. There is the hardware unit which
is connected to the machine, and there is the logical device which is a name given
by the OS to a legal entry point for talking to a hardware-device. When a user
writes to a logical device, the OS invokes a device driver which performs the
physical operations of controlling the hardware. For example, when writing
to a disk, the OS must control the movement of the read-write heads. When
writing to a printer, the OS places the information in a queue and services the
request when the printer becomes free.

Some common logical devices are: the system disks, the keyboard, the screen,
the printer and the audio device.

Disks and tapes are foten called secondary memory or secondary storage.


1.2.4 Interrupts, traps, exceptions

Interrupts are hardware signals which are sent to the CPU by the devices it is
connected to. These signals literally interrupt the CPU from what it is doing
and demand that it spend a few clock cycles servicing a request. For example,
interrupts may come from the keyboard because a user pressed a key. Then
the CPU msut stop what it is doing and read the keyboard, place the key value
into a buffer for later reading, and return to what it was doing. Other 'events'
generate interrupts: the system clock sends interrupts at periodic intervals, disk
devices generate interrupts when they have sensors and detectors. User programs
can also generate 'software interrupts' in order to handle special situations like
a 'division by zero' error. These are often called traps or exceptions on some
systems.

Interrupts are graded in levels. Low level interrupts have a low priority,
whereas high level interrupts have a high priority. A high level interrupt can
interrupts a low level interrupt, so that the CPU must be able to recover from
several 'layers' of interruption and end up doing what it was originally doing.
This is accomplished by means of a stack or heap. Moreover, programs can
often choose whether or not they wish to be interrupted by setting an interrupt
mask which masks out the interrupts it does not want to hear about. Masking
interrupts can be dangerous, since data can be lost. All systems therefore have
non-maskable interrupts for the most crucial operations.


1.3 Software


1.3.1 Resource management

In order to keep track of how the system resources are being used, an OS must
keep tables or lists telling it what is free and what is not. For example, data
cannot be stored neatly on a disk. As files become deleted, holes appear and
that data become scattered randomly over the disk surface.


1.3.2 Spooling

Spooling is a way of processing data serially. Print jobs are spooled to the 
printer, because they must be printed in the right order (it would not help
the user if the lines of his/her file were liberally mixed together with parts of
someone elses file). During a spooling operation, only one job is performed at
a time and other jobs wait in a queue to be processed. Spooling is a form of
batch processing.

Spooling comes from the need to copy data onto a spool of tape for storage.
It has since been dubbed Simultaneous Peripheral Operating On-Line, which
is a pretty lousy attempt to make something more meaningful out of the word
'spool'!


1.3.3 System calls

An important task of an operating system is to provide black-box functions
for the most frequently needed operation, so that users do not have to waste
their time programming very low level code which is irrelevant to their purpose.
These ready-made functions comprise frequently used code and are called system
calls.

For example, controlling devices requires very careful and complex programming.
Users should not have to write code to position the head of the disk drive
at the right place just to save a file to the disk. This is a very basic operation
which everyone requires and thus it becomes the responsibility of the OS. Another
example is mathematical functions of graphics primitives.

System calls can be thought of as a very simple protocol - an agreed way of 
asking the OS to perform a service. Some typical OS calls are: read, write (to
screen, disk, printer etc), stat (get the status of a file: its size and type) and
malloc (request for memory allocation).

On older microcomputers, where high level languages are uncommon, system
calls are often available only through assembler or machine code. On modern 
systems and integrated systems like UNIX, they are available as functions 
in a high level language like C.


1.3.4 Basic command language

Commands like

dir		; list files (DOS)
ls		; list files (UNIX)
cd		; change directory
copy file prn	; copy file to printer
myprog		; execute program 'myprog'

constitute a basic command language. Every computer must have such a language
(except perhaps the Macintosh - yawn!). In microcomputer operting
systems the command language is often built into the system code, whereas on
larger system (UNIX) the commands are just executable programs like the last
example above.

The command language deals typically with: file management, process management
and text editing.


1.3.5 Filesystem

In creating a system to store files we must answer some basic questions.

  * Should the filesystem distinguish between types of file e.g. executable
    files, text file, scripts. If so how? One way is to use file extensions,
    or a naming convention to identify files, like myprog.exe, SCRIPT.BAT,
    file.txt. The problem with this is that the names can be abused by users.
    If one tries to execute a file which is not meant to be executed, the result
    would be nonsense and might even be dangerous to the point of crashing
    the system. One way around this problem is to introduce a protocol or
    standard format for executable files, so that when the OS opens a file for
    execution it first checks to see whether the file obeys the protocol. This
    method is used for binary files in UNIX, for intance.

  * Procection. If several users will be storing files together on the same disk,
    should each user's files be exclusive to him or her?

  * Is a mechanism required for sharing files between serveral users?

  * A hierarchical filesystem is a good starting point for organizing files, but
    it can be too restrictive. Sometimes it is useful to have a file appear in
    several places at one time. This can be accomplished with links. A link 
    is not a copy of a file, but a pointer to where a file really is. By making
    links to other places in a hierarchical filesystem, its flexibility is increased
    considerably.


1.3.6 Multiple windows and screens

Multitasking cannot be fully exploited if each user has only one output terminal
(screen). Each interactive program needs its own screen and keyboard. There
are three solutions to this program:

  1.Several physical screens can be attached to the computer. This is expensive
    and probably wasteful.

  2.Toggling between 'logical screens'. By pressing a key on the keyboard
    the user can switch between two different images, which are separately
    maintained in memory.

  3.Window system.

The technology for the last of these solutions has only been available for a few
years. While it is clearly the best of the three (and can be combined with), it
requires a considerable amount of memory and CPU power to implement. The 
problems of overlapping windows requires there to be a manager which controls
the sharing of space on the screen. All of the graphics must be drawn and
redrawn continuously. The operating system must provide primitives for doing 
this. 

We shall not consider windowing further in this text, but it is worth bearing
in mind that the principles are very similar to those of operating systems.
Sharing and management are the key concepts.


Note

Before proceeding, you should note that the design of operating systems is an
active area of research. There are no universal solutions to the issues that we
shall discuss, rather OS design must be thought of as a study of compromises.
Hopefully you will get a feel for this during the course of the tutorial.

