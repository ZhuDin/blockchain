Chapter 3 Node and MongoDB Basics

Before we dig in and start building a full-blown web application using Node and MongoDB, it's
important that we review some of the basics. This chapter will give you a crash course on syntax
and important topics. It is broken down into two parts, where the first half focuses on JavaScript
or Node, and the second half covers MongoDB. You will gain insight into some of the more
common and powerful tools available to you, and a lot of sample code will be reviewed to get
you up to speed.

In this chapter, we will cover the following topics:
	* Fundamentals of the JavaScript language
	* The basics of Node.js
	* Node's package manager, npm
	* The basics of MongoDB

By the end of this chapter, you should have a solid understanding of the syntax and how to use
both Node and MongoDB. There's a lot to cover, so let's get started.


A JavaScript primer

As we already know, Node.js is not just another language, but JavaScript. The language syntax
and tools you used while coding JavaScript on the browser will work verbatim on the server.
Node.js has additional tools that are only available on the server, but the language and syntax are
again the same as JavaScript. I'm assuming you have a general understanding of the basic
JavaScript syntax, but I will introduce JavaScript to you with a very brief primer on the
language, just in case.

In general, JavaScript is a fairly simple language when it comes to syntax, and you only need to
know a few important elements.


Introducing es6

The es6, or ECMAScript, 2015 is a JavaScript language update for all types, values, object
literals, properties, functions, and program syntaxes. The whole new semantics of es6 (which is
similar to other languages like Java, C#, and so on) invites cross-platform developers to learn
JavaScript with ease. Not only it improve the languages in syntactical aspects, it also provides
new inbuilt tools, such as promises, proper tail calls, destructuring, modules, and so on. As we
have already installed Node version 8, all the ECMAScript 6 features or es2017 till date are
inclusive. If you are using a Node version less than 4.3.2, you will need to install transcompilation 
tools like babel.js. We will be learning es6 by making a gradual implementation in
code and a comparative study as well.


Syntax basics

The most basic thing you can do in pretty much any programming language is declare a variable.
Unlike most other languages, JavaScript is a dynamically-typed language, which means when
you declare a variable, its value can be of any type and can change during the course of its
lifetime. However, in contrast, a strongly-typed language dictates that a variable defined as a
string type must always be a string and must always have a value of a string. The strong typed
feature is included in es6 which we are going to learn next. For now, to declare a variable in
JavaScript, simply use the var keyword before your variable name:

	var myVariable; // declaring a variable with no value
	var myFirstName = "Jason";
	var myLastName = "Krol";
	var myFullName = myFirstName + ' ' + myLastName;
	// => Jason Krol 

The preceding code snippet shows how we declare variables and define them with initial values
alongside their declarations. The + operator is used for string concatenation.

Also, we use camel case for the variable names. It is not mandatory that you use camel case for
variable naming, but it is more common in object-oriented languages to follow camel case as
opposed to the underscore-based approach.

JavaScript won't complain if you forget to put a semicolon at the end of each statement. Instead,
it will attempt to put the semicolons for you if there are proper statement terminations missing.
This can lead to unexpected results. The rules of semicolon insertion are explained in this article
at http://bclary.com/2004/11/07/#a-7.9.1.

Since, es6 has introduced two more keywords for variable declarations, namely let and const,
has made JavaScript a lot more elegant. First, lets learn const by considering the following
example:

	const loopOver = [1,2,3];

The usage of const is same as var. Declaring a variable with const makes itself immutable and it
cannot be used for reassigning new content in itself.

One more distinction about the const keyword that it does not mean something is constant but it
emphasizes one time assignment.

Let's test it by adding the following line:

	loopOver = [4,5,6];

It throws the following error:

	Uncaught TypeError: Assignment to constant variable

Well, Why is it needed? The recommended practice for coder is to keep things simple which
means using a single variable to represent a single value for a time. However, we discussed about
the dynamicity of the variable earlier which has its own advantages, sometimes there is need to
represent a data which is immutable itself. Like store some credentials of server configuration or
the Node packages itself. The usage can vary but will be applied with a single rule of one time
assignment.

To study the let keyword, we need to know about the scope of variables first which is covered in
the following section.


Understanding the scope of variables

Understanding the scope of variables is very important in JavaScript to gain a better hold of the
language. Scope may be referred to as a bucket in which your variable or your function exists.
Unlike Java and other popular languages, JavaScript follows function-level scoping as opposed
to block-level scoping (which is now introduced in es6). So, this means that the variables you
define will be limited to a scope that is bound to its parent function.

Consider the following code snippet:

	var outer = 10;
	function myFunction() {
	 var inner = 2;
	 console.log(inner);// 2
	 console.log(outer);// 10
	}myFunction();console.log(inner); 

When you run the preceding code, we can see the scope of the inner variable is limited to the
parent function named myFunction. It won't be accessible outside it and will provide a
referenceError notification. Also, the variables available in outer scopes are available in function
scopes, and you don't need to make any extra effort to access them, as you have seen with the
variable named outer in the preceding example.

An important thing to discuss in this context is the use of the var keyword. JavaScript won't
complain if you miss var while declaring a new variable. But things can get really bad if that
happens. See the following example:

	(function (){
	 (function (){
	 a = 10;
	 })();
	})();
	console.log(a);// 10 

Here, as the var keyword was skipped along with the variable declaration inside the inner
function, JavaScript considered that this variable should be searched in its parent scopes, then
attached it to the global scope, and ended up making it available everywhere. So, to avoid such
issues with the code, it is always useful if you pass your code through code quality tools such as
JSHint. The preceding code structure may have confused you, as it used self-invoked functions
just to induce scopes.

Now with the arrival of es6, you can declare variables with the block scope rather than only the
function scope. To understand the block level scoping, let's go through the following example:

	for(let i=0;i<loopOver.length;i++){
		console.log(`Iteration : ", i)
	}
	Console.log(`Let value of ${ i}`)
	
The only difference in preceding snippets is the declaration of variable i. The i variable is not
accessible outside the for loop block.

For more details regarding let refer the link:
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let

So that was all about scope of variables. JavaScript supports a number of data types. Let's take a
look at them.


Data types

Data types are the base of any language. The data types available in JavaScript are
as follows:
	* Number
	* String
	* Boolean
	* Object
	* Null
	* Undefined
	* Symbol (new in es6)

In our code, every variable we declare will contain values that belong to any of the preceding
types. Number, String, and Boolean types are quite straightforward to understand. These comes
under the primitive data types supported by the language. Here, one important point is to note
that JavaScript has no distinction between integers or floating points at its type level.

Types such as array, function, regex, and date come under the object data type.
They are considered to be composite data types. So the functions that you define
in your code will also be nothing but objects.

Null and undefined are two special types supported by JavaScript. Null points
to a deliberate non-value, whereas undefined points to an uninitialized value. So, when you just
declare a variable and haven't yet initialized it with a value, the variable will be of undefined
type. Last but not least, es6 has introduced a new primitive data type of symbol. They are used
for unique property keys and constants representative concepts.

We are not using them in context of our book, however you can visit the following link for more
details http://exploringjs.com/es6/ch_symbols.html.

So before we understand various ways to define functions, arrays, and objects, lets go through
operators and flows.


Operators and flows

JavaScript supports similar control structures to other languages in the C family. Conditional
statements are written with if and else, and you can chain together the statements using else-if
ladders.

	var a = "some value";
	if(a === "other value") {
	 //do something
	} else if (a === "another value") {
	 //do something
	} else {
	 //do something
	} 

Control statements can be written using while, do-while, for, and switch statements. One
important thing to consider while writing conditions in JavaScript is to understand what equates
to true and/or false. Any value greater or less than zero, not null, and not undefined equates to
true. Strings such as 0, null, undefined, or empty strings equate to false.

Some sample examples using while, do-while, for, and switch statements are as follows:

	// for loop example
	var myVar = 0;
	for(let i = 0; i < 100; i += 1) {
	 myVar = i;
	 console.log(myVar); // => 0 1 ... 99
	}

	// do while example
	var x = 0;
	do {
	 x += 1;
	 console.log(x); // => 1 2 ... 100
	} while (x < 100);

	// while example
	while (x > 90) {
	 x -= 1;
	 console.log(x); // => 99 98 ... 90
	}

	//switch example
	var x = 0;
	switch(x) {
	 case 1 :
	console.log(""one"");
	break;
	 case 2 :
	console.log("two"");
	break;
	 default:
	console.log("none");
	} // => "none" 

Another important thing will be to understand the basic difference between
the comparisons using == and ===. The == comparisons should be used where
the type of variable is not your concern; and if the data type of the variables also should be
compared, then you should opt for a === comparison symbol as given in the following code:

	const a = '5';
	const b = 5; 
	if(a == b) {
	 //do something
	}
	if(a === b) {
	 //do something
	} 

Here in the code snippet, the first condition evaluates to true while the second doesn't. So while
you code, it's always safer to depend on strict (===) equality checks as a best practice.

It's always advised to run your code through code quality tools such as JSHint before you
approve them for your application. You can automate the code quality checks via task runners
such as Grunt so that each time we make a change in our code, the code quality tool runs and
presents if there are any potential issues with the code that has been written.


Understanding objects

In JavaScript objects, the arrays and even functions we create fall into the same data type: Object.
Declaring an object is a fairly straightforward process:

	var myObject = {}; // that's it! 

You may add properties or attributes to this object, which may belong to any type. It means you
can add arrays, functions, or even other objects as properties of this object. Adding a new
property to this object can be done in any of the two ways shown here:

	var person = {};
	person.firstName = 'Jason'; // via dot operator
	person['lastName'] = 'Krol'; // via square brackets 

Let's look at an example where we add arrays and functions as properties of this object:

	var person = {};
	person.firstName = 'Jason'; // properties
	person.lastName = 'Krol';
	person.fullName = function() { // methods
	 return this.firstName + ' ' + this.lastName;
	};
	person.colors = ['red', 'blue', 'green']; // array property 

You can see in the preceding code that we defined a basic object called person and assigned it
some properties and a function. It's important to note that the use of the this keyword in the
fullName function. The this keyword refers to the object that the function is a part of. So via the
this keyword, the function will be able to access the other properties that are part of the object it
belongs to.

Apart from the approach of adding properties after the object creation, we can also attach the
initial object properties as part of its creation, as follows:

	// define properties during declaration
	var book = {
	 title: 'Web Development with MongoDB and NodeJS',
	 author: 'Jason Krol',
	 publisher: 'Packt Publishing'
	};
	console.log(book.title);
	// => Web Development with MongoDB and NodeJS
	book.pageCount = 150; // add new properties

In the preceding example, we are creating objects without specifying any class from which they
should be created by using {}. So, this results in the creation of this new object from the Object
base class from which other composite types such as arrays and functions are extended. So, when
you use {}, it is equivalent to a new Object().

Here, the objects we create via the use of the object literal {} are instances of the Object class. To
define custom classes for our application, we will need to use functions and prototypes. Mozilla
has a fairly good tutorial on introducing this whole point, available at
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_ObjectOriented_JavaScript. 
The es6 has enhanced the object properties by adding various features as:
First and foremost of all is property shorthand. Now with es6 we can assign property using a
variable. Lets understand this using the following example:

	let publisher = 'Packt Publishing';
	let book = { publisher };
	console.log(book.publisher);

In the preceding snippet, the variable value is implicitly assigned to object property and there is
no need to have a property specified while declaring an object.

The next amazing feature is computation of property key in object literals. To learn this feature,
let's add a property to the preceding object called book.

	let edition = 3;
	let book = {publisher,[ `Whats new in ${edition} ? `] : "es6 and other improvisation"}

The es6 introduces us to one of the most awaited feature called the template literals. You may
have noticed a kind of interpolation operation used in preceding snippets with placeholder ${}. It
is nothing but a concatenation of variable in string without using any operator, such as +. The
template literal enhances the feature of readability in JavaScript which is quite essential. For
more information follow the link
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals.

Once we run the preceding code, we note that es6 enables us to perform any computation for
property names using a square bracket. Lastly, we can follow an elegant feature of the method
notation in the object property for all functions. This can be seen in the following example:

	var person = {
	 firstName : 'Jason',
	 lastName : 'Krol', // properties
	 fullName() { // method notation
	 return this.firstName + ' ' + this.lastName;
	}
	};

Always remember that objects are nothing but an address of a memory location and not actual
storage. For instance, firstName: 'Jason' is stored in memory location with address
person.firstName. Until now, we have learned about a single point of storage called as variables,
moving further let's learn multiple point of storage.


Understanding arrays

Arrays work the same way in JavaScript as they do in pretty much any other language. They are
zero indexed, and you can declare a variable as an empty array or a pre-populated array. You can
manipulate the items in an array, and arrays are not fixed in length:

	var favFoods = ['pizza', 'cheeseburgers', 'french fries'];
	var stuff = []; // empty array
	var moreStuff = new Array(); // empty array
	var firstFood = favFoods[0]; // => pizza
	// array functions:
	favFoods.push('salad'); // add new item
	// => ['pizza', 'cheeseburgers', 'french fries', 'salad']
	favFoods.pop(); // remove the last item
	// => ['pizza', 'cheeseburgers', 'french fries']
	var first = favFoods.shift(); // remove the first item
	// => first = 'pizza';
	// => favFoods = ['cheeseburgers', 'french fries'] 

To be more precise, you can consider arrays as extended child classes of the base Object class
with extra implementations of Array functions.


Understanding functions

Functions are first-class citizens in JavaScript. What this means is that a function by itself is an
object, so it can be treated as such and extended with properties and additional functions to the
base Object class. We will see a lot of situations where we pass functions as parameters to other
functions and return functions from other function calls.

Here, we will take a standard function (in this case, myFunction). We will assign this function a
timesRun property, just like we do for any other object during its execution, and see how to refer
to that property later:

	var myFunction = function() {
	 if(this.timesRun)
		this.timesRun += 1;
	 else
	 	this.timesRun = 1;
	 // do some actual work

	 console.log(this.timesRun);
	};
	myFunction();
	// => 1;
	myFunction();
	// => 2;
	myFunction();
	// => 3; 

As we have seen in the preceding example, by using the var keyword, we can define functions in
the same way as variables:

	function sayHello() {
	 console.log('Hello!');
	}
	// or
	var sayHello = function() {
	 console.log('Hello!');
	};

Both methods are almost identical in the preceding sample code. The first method is the most
common way to define a function, and is called the named function approach. The second
method discussed here is the function expression approach, where you assign the unnamed
function as a reference to a variable and keep it unnamed.

The single most important difference between these two approaches is related to a concept called
JavaScript hoisting. Basically, the difference is that when you adopt a function expression
strategy, the function will not be available in its containing scope till the point, its definition
statement gets executed. In the named function approach, regardless of the position you define it
at, the function will be available throughout the containing scope as given in the following code:

	one();//will display Hello
	two();//will trigger error as its definition is yet to happen.
	function one() {
	 console.log('Hello!');
	}
	var two = function() {
	 console.log('Hello!');
	};
	two ();//will display Hello 

In the preceding sample code snippet, function one can be invoked from anywhere in its parent
scope. But function two will not be available before the point where its expression is evaluated.

JavaScript hoisting is the process by which the function definitions and variable declarations are
moved to the top of the containing scope by the JS interpreter before the script is executed. So, in
the previous case of named functions, the definition was moved to the top of the scope. However,
for the function expression, only the declaration of the variable moved to the top of the scope,
setting it to undefined till the point in the script where it was actually executed. You can read
more about the concept of hoisting at http://code.tutsplus.com/tutorials/JavaScript-hoistingexplained--net-15092.


Anonymous functions and callbacks

Often, you will need to use a temporary function that you don't necessarily want to declare ahead
of time. In this type of scenario, you can use an anonymous function, which is simply a function
that is declared at the time you need it. This is similar to the function expression context we
explored earlier, with a simple difference that the function isn't assigned to a variable so it has no
way of being referenced to later. The most common use of anonymous functions is when they are
defined as a parameter to another function (most notably when used as a callback).

One of the most common places to use an anonymous function (which also acts as a callback
even if you didn't realize it) is with setTimeout or setInterval. These are two standard JavaScript
functions that will execute code after a specified delay (in milliseconds) or repeat the execution
of code after a specified delay. Here is an example of one of them, setTimeout, using an
anonymous inline function:

	console.log('Hello...');
	setTimeout(function() {
	 console.log('World!');
	}, 5000);
	// => Hello...
	// (5000 milliseconds i.e. 5 second delay)
	// => World! 

You can see that the anonymous function was passed as the first parameter to setTimeout because
setTimeout expects a function. You can, if you desire, declare the function ahead of time as a
variable and pass that to setTimeout instead of the inline anonymous function:

	var sayWorld = function() {
	 console.log('World!');
	}
	setTimeout(sayWorld, 5000);
	// (5 second delay)
	// => World! 

The anonymous function just acts as a clean inline disposable function.

Callbacks are important because one of the most powerful (and confusing) features of JavaScript
is that it's asynchronous. This means that every line executes sequentially, but it doesn't wait
around for code that might be taking longer than it should (even if by design). We have explored
this via an example in the first chapter while looking into the asynchronous nature of Node.js.

Mozilla has a detailed tutorial on JavaScript concepts, which we advise you to go through once
you finish this chapter. The tutorial includes highly advanced concepts, such as closures, that
were not covered in this chapter due to the depth of the topic. So refer to this Mozilla
Development Network article at https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_reintroduction_to_JavaScript.


JSON

JavaScript Object Notation (JSON) is the standard syntax used when dealing with data in
JavaScript as well as most other languages and web services. The basic premise of JSON is that
it looks exactly like a standard JavaScript object with a few strict exceptions:
	* JSON is pure text. There are no data types with properties; that is, date values are stored as strings and so on
	* All names and string values must be in double quotes
	* There can be no functions as properties

Let's take a quick look at a pretty standard JSON object:

	{
	 "title": "This is the title",
	 "description": "Here is where the description would be",
	 "page-count": 150,
	 "authors": [
	 { "name": "John Smith" },
	 { "name": "Jane Doe" },
	 { "name": "Andrea Johnson" }
	 ],
	 "id": "1234-567-89012345"
	} 

If you are at all familiar with XML, JSON is somewhat similar, except it is much easier to read
and make sense out of. As described best by the ECMA, "JSON is a text format that facilitates
structured data interchange between all programming languages".


The basics of Node.js

With the basics of JavaScript out of the way, let's focus on some of the basics of Node. We will
start by understanding the node.js core architecture. The significance of different node features
lies in its architecture and way it works. Let us study it carefully in the following section.


Node.js architecture

The web application normally follows three tier web architecture consisting of client, web server,
and data source. In our context, we have created a web app server using Node.js. As we
discussed in chapter 1, Welcome to JavaScript in The Full Stack, Node.js follows a single
threaded architectural model. To reduce the memory leak and understand asynchronousity while
writing the code, we need to understand how Node.js works.

Every processing component is sequenced in the following order"
	
	1. The client sends a request (consider an HTTP request).
	
	2. The Chrome's v8 engine is a just-in-time (JIT) compiler. Once the request is received at the server, v8 converts the JavaScript code to the machine code.
	
	3. The C++ APIs within the Node.js core provide a binding for other system-level components. Binding is basically a wrapper library so that a code written in one language can communicate with a code written in another language. This API is responsible for emitting an event.
	
	4. Once the event is emitted, it is stored in the event queue.
	
	5. The eventloop is responsible for fetching the event from the queue and executing it in the callstack.
	
	6. If an event requires an asynchronous operation to be done, such as using database files, it switches its execution context to another worker thread and gets executed. This is done by libuv. The libuv library is responsible for handling the asynchronous behavior of an event life cycle in the system. It is written in C. It maintains a pool of threads to handle asynchronous requests such as I/O and network-related operations.
	
	7. Once the asynchronous operation is completed, it returns the callback. The callback remains in the event queue until the callstack gets empty.

	8. Once the callstack is empty, the eventloop pulls the callback from the event queue and executes it in the callstack.

	9. Eventually, the event returns the data to the Node API.

	10. In each loop, it performs a single operation. Though the operations are performed sequentially, this single-threaded mechanized eventloop is so fast that it provides an illusion of concurrency. A single thread can utilize a single core of the system; hence, it provides better performance and minimal response time to client.


Event-driven

At its core, one of the most powerful features of Node is that it is event-driven. This means that
almost all the code you write in Node is going to be written in a way that is either responding to
an event or is itself firing an event (which in turn will fire other code listening for that event).

Let's take a look at the code that we'll write in a later chapter that handles connecting to a
MongoDB server using Mongoose, a popular Node.js MongoDB Object Document Mapper
(ODM) module:

	mongoose.connect(');
	mongoose.connection.on('open', function() {
		console.log("Connected to Mongoose...");
	}); 

First, we tell our mongoose object to connect to the server provided as a string parameter to the
function. Connecting will take an undetermined amount of time though, and we have no way of
knowing how long. So, what we do is bind a listener to the open event on the mongoose.connection
object. With the use of the on keyword, we are indicating that when the mongoose.connection
object triggers an open event, it executes the anonymous function that was passed in as the
parameter.


Asynchronous execution

Earlier, we reviewed the idea of asynchronous JavaScript code in the browser using setTimeout;
the principles apply more strongly in the world of Node. As you may be making a number of
network-dependent connections to different REST API services, database servers, and anything
else, it is important that your code can be executed smoothly and has proper callback usage in
place whenever each service responds.


The module system

In an effort to make the code as modular and reusable as possible, Node uses a module system
that allows you to better organize your code. The basic premise is that you write a code fulfilling
a single concern, and export this code using module.exports (or simply exports) as a module that
serves that single purpose. Whenever you need to use that code elsewhere in your code base, you
will require that module:

	// ** file: dowork.js
	module.exports = {
	 doWork: function(param1, param2) {
	 	return param1 + param2;
	 }
	}
	// ** file: testing.js
	var worker = require('./dowork'); // note: no .js in the file
	var something = 1;
	var somethingElse = 2;
	var newVal = worker.doWork(something, somethingElse);
	console.log(newVal);
	// => 3 

Using this system, it is simple to reuse the functionality in a module (in this case, the dowork
module) in a number of other files. Furthermore, the individual files of a module act as a private
namespace, which means every file defines a module and is executed separately. Any variables
declared and used within the module file are private to that module and not exposed to any code
that uses the module via require(). The developer has control over which part of module will be
exported or not. Such implementation of modules is called as the commonJs modules pattern.

Before we conclude module system in Node.js, we need to learn about the require keyword. The
require keyword accepts an address of a file as string and provides it to JavaScript engine to
compile it into a method Module._load. The Module._load method is executed for first time, it
actually loads from the exported file and further it is cached. Caching is done so as to reduce the
number of file reads and can speed up your application significantly. In addition, when a module
is loaded next time, it provides an instance of that loaded module from cache. This allows
sharing of modules across the project with the state of singleton. At the end, the Module._load
method returns the module.exports property of the addressed file on their respective execution.

The module system extends infinitely as well. Within your modules, you can require other
modules and so on and so forth. Make sure while importing it, do not cause so called a cyclic
dependency.

Cyclic or circular dependency is a situation when a module requires itself directly or indirectly.
We can learn about this more from the discussion in the following link :
https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-nodejs.


The Node.js core

The Node.js core literally has hundreds of modules available for you to use while writing your
applications. These modules are already compiled into binary and are defined within Node.js
source code. These include the following:
	* Events
	* Filesystems

Just like other languages, the Node.js core also provides an ability to interact with filesystem
using the fs module. This module is equipped with different methods for performing different
operations on file synchronously as well as asynchronously. Refer chapter 1. Welcome to
JavaScript in The Full Stack to learn more about the difference of sync and async. The
synchronous methods of fs are suffixed by the keyword Sync for instance readFileSync. For all
reviewing the module in depth refer the following link : https://nodejs.org/api/fs.html.


HTTP

An HTTP module is one of the most important module in Node.js core. HTTP module provides
functionality to implement an HTTP client as well as server.

Following is the minimum code required to create a basic server and a client:

	const http = require('http');
	//create a server object
	http.createServer((req, res)=>{
	 res.write('Hello Readers!'); //write a response to the client
	 res.end(); //end the response
	}).listen(3000); //the server object listens on port 3000

	const http = require('http');
	http.get({
	 hostname: 'localhost',
	 port: 3000,
	 path: '/'
	}, (res) => {
	 res.setEncoding('utf8');
	 res.on('data', (chunk)=>{
	 	console.log(`BODY: ${chunk}`);
	 });
	});

Considering the preceding code, once the module is required, we use an instance of the HTTP
Object to either create a server or to request a server on the other side. The createServer method
requires a callback as a parameter. This callback is called whenever the server is hit by an HTTP
request. Further, it also provides a response object as a parameter to handle the response back
accordingly.


Net

The preceding HTTP module is wired using the net module. According to documentation of the
node.js api, the net module provides an asynchronous network API for creating stream-based
TCP or IPC servers. This is one of the compiled binary library of core Node, which interacts with
the internal C library called libuv. The libuv library is responsible for handling asynchronous
request such as I/O and network-related operations. The best documentation to refer is Node's
own documentation: https://nodejs.org/api/net.html.


Streams

The stream is one of the most significant module among the core modules. To define the stream
in simple words, it is the flow of data received as small data chunks from a particular source. At
the receiver's end, it might neither have all the stream data nor it will have to fit it memory all at
once. This allows us to handle a large amount of data with limited resources. We can visualize
the stream by an analogy given by Dominic Denicola. According to him:

"Streams are to asynchronous iterables as arrays are t synchronous iterables".

Consider if we need to read a large file of data in the environment where multiple read/write
operations takes place. In such cases, streams provides a powerful abstraction to handle the 
lowlevel I/O system calls while still providing performance benefits.

The internal stream module should not be used directly so as to avoid the behavioral changes
between Node versions. However, we can use the wrapper modules like readable-streams on the
npm.

Although, streams are not extensively used in context of our book, it is one of the backbone
feature of Node.js core used by its internal modules itself and has always been a big part of
Node.js ecosystem. To learn more about streams follow the link:
https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/.

Definitely make sure to check out the online docs on Node at: http://nodejs.org/api, to see the full
list of modules available in Node's core and see plenty of sample code and explanations.


Installing modules using npm

The module system in Node is very powerful that consuming a third-party module written by
other developers is a piece of cake. Node includes its own package manager called npm, which
is a registry that currently contains over 475,000 modules written in Node. These modules are
completely open source and available to you via a few short commands. In addition, you can
release your own personal modules via npm and allow anyone in the world to use your feature!

Let's say you want to include a popular web framework, express, in your project (the one we will
be using later in this book). There are two simple steps required to download a module and use it
in your code:

	$ npm install express
	 // ** file: usingnpm.js
	 var express = require('express'); 

And that's it! Literally, it's that simple! From the command line of the folder where your project
is located, simply execute npm install package-name, and the package will be downloaded from
npm and stored in a folder called node_modules within your project. If you browse through the
node_modules folder, you will find a folder for the package you installed, and within that folder,
you will find the raw source code for the package itself. Once the package is downloaded, it's as
simple as using require() within your code.

There may be times when you want to install a Node package globally, for example, when using
a popular command-line build tool called Grunt.js. To install an npm package globally, simply
include the -g or --global flag, and the module will be installed as a global executable instead.
When installing npm packages globally, the source files for the package are not stored within the
node_modules folder of a specific project, but instead within a node_modules folder in a system
directory of your machine.

A really powerful feature of npm is that it allows a quick, easy, and consistent way for other
developers to boot up your code in their local environment. Node projects, typically, include a
special file called package.json that contains information about the project as well as a list of all
npm packages that the project depends on. A developer with a copy of your local code can
simply execute npm install to have every dependency downloaded and installed locally using
this file.

The npm install flag --save or --save-dev is required if you want the dependency that you are
installing to be saved to the package.json file. If you are starting a new project and don't want to
create a package.json file by hand, you can simply execute npm init and answer a few quick
questions to get a default package.json file quickly set up. You can leave every question blank
during init and accept the default values if you want:

	$ npm init

	$ npm install express --save
	$ npm install grunt --save-dev
	$ cat package.json
	{
	"name": "chapter3",
	"version": "0.0.0",
	"description": "",
	"main": "index.js",
	"scripts": {
	"test": "echo \"Error: no test specified\" && exit 1"
 	},
	"author": "",
	"license": "ISC",
	"dependencies": {
	"express": "^3.5.1"
	},
	"devDependencies": {
	"grunt": "^0.4.4"
	}
	}

The dependencies and devDependencies sections have express and grunt listed. The difference
between these two sections is that the dependencies section is absolutely critical for the app to
function properly and the devDependencies section has only packages that need to be installed for
a developer to use during the development of the project (such as Grunt for various build steps,
testing frameworks, and so on). If you are confused about the use of the ^ symbol in the package
versions, it's used to update the dependency to the most recent minor version or patch version
(the second or third number). ^1.2.3 will match any 1.x.x release including 1.3.0, but will hold
off on 2.0.0. So, in our case ^3.5.1 of Express.js will look for the most recent minor version of
express.js but will not take 4.0.0, as it's a major version.


The basics of MongoDB

Since MongoDB is largely powered by JavaScript, the Mongo shell acts as a JavaScript
environment. In addition to being able to execute regular Mongo queries, you can also execute
standard JavaScript statements. Most of the items mentioned earlier in the JavaScript primer
apply directly to the Mongo shell as well.

In this section, we will primarily focus on the various ways to perform standard CRUD
operations via the Mongo shell.


The Mongo shell

To access the Mongo shell, simply execute mongo from any terminal. The Mongo shell requires
the mongod server to be currently running and available on the machine, as the first thing it does is
connect to the server. Use the following command to access the Mongo shell:

	$ mongo
	MongoDB shell version: 2.4.5
	connecting to: test
	>

By default, when you first launch Mongo, you are connected to the local server and set to use the
test database. To display a list of all databases on the server, use the following command:

	> show dbs

To switch databases to any of those listed in the output of show dbs, use the following command:

	> use chapter3
	switched to db chapter3

An interesting thing to note is that if you use use on a database that doesn't exist,
one will be created automatically. If you are using an existing database and want to view a list of
collections in the database, execute the following command:

	> show collections

In this case of my chapter3 database, I had no existing collections since it was automatically
generated as a new database for me. Collections in MongoDB are similar to the tables in a
relational database.


Inserting data

Since we are working with the chapter3 database, which is a brand new database, there are
currently no collections in it. You can use any collection (table) you want by simply referring to
a new collection name with the db object:

	> db.newCollection.find() 

Performing a find operation on an empty collection simply returns nothing. Let's insert some data
so we can experiment with some queries:

	> db.newCollection.insert({ name: 'Jason Krol', website:
	 'http://kroltech.com' })
	> db.newCollection.find().pretty()
	{
	 "_id" : ObjectId("5338b749dc8738babbb5a45a"),
	 "name" : "Jason Krol",
	 "website" : "http://kroltech.com"
	} 

After we perform a simple insertion (basically of a JavaScript JSON object), we will perform
another find operation on the collection and get our new record returned, this time with an
additional _id field added. The _id field is Mongo's method for tracking a unique identifier for
every document (record). We also chained the pretty() function to the end of the find(), which
outputs the results a little more nicely.

Go ahead and insert a few more records, so you have some data to play with for the next section
when we go over querying.


Querying

Querying and searching for documents in a MongoDB collection is pretty straightforward. Using
the find() function by itself with no parameters will return every document in the collection. To
narrow down the search results, you can provide a JSON object as the first parameter with as much
or as little specific information to match against as you wish, as shown in the following code:

	> db.newCollection.find({ name: 'Jason Krol' })
	{ "_id" : ObjectId("533dfb9433519b9339d3d9e1"), "name" : "Jason
	Krol", "website" : "http://kroltech.com" }

You can include additional parameters to make the search more precise:

	> db.newCollection.find({ name: 'Jason Krol', website: 'http://kroltech.com'})
	 { "_id" : ObjectId("533dfb9433519b9339d3d9e1"), "name" : "Jason
	 Krol", "website" : "http://kroltech.com" }

With each result set, every field is included. If you want to only return a specific set of fields
with the result, you can include map as the second parameter to find():

	> db.newCollection.find({ name: 'Jason Krol' }, { name: true })
	{ "_id" : ObjectId("533dfb9433519b9339d3d9e1"), "name" : "Jason Krol"
	 }> db.newCollection.find({ name: 'Jason Krol' }, { name: true, _id:
	 false })
	{ "name" : "Jason Krol" }

The _id field will always be included by default, unless you specifically state that you don't want
it included.

Additionally, you can use query operators to search for things that are within ranges. These
include greater than (or equal to) and less than (or equal to). If you want to perform a search
against a collection of homework, and you want to find every document with a score within the
B range (80-89), you can execute the following search:

	> db.homework_scores.find({ score: { $gte: 80, $lt: 90 } }) 

Finally, you can use regex while performing a search to return multiple matching documents:

	> db.newCollection.find({ name: { $regex: 'Krol'} }) 

The preceding query will return every document that contains the word Krol. You can get as
advanced as you want with regex statements.

If you know that you are going to be returning multiple documents on a query and only want the
first result, use findOne() in place of a regular find() operation.


Updating data

To update a record, use the update() function, but include a find query as the first parameter:

	> db.newCollection.update({ name: 'Jason Krol' }, { website: 'http://jasonkrol.com' })

There's a bit of a catch here. If you perform a new find({ name: 'Jason Krol' }) operation,
something strange happens. No data is returned. What happened? Well, the second parameter in
the update() function is actually the new version of the complete document. Since, you only
wanted to update the website field, what actually happened was that the document that was found
was replaced with the new version that consists of only the website field. To reiterate, the reason
this happens at all is because with NoSQL such as MongoDB, the document does not have a set
number of fields (as a relational database does). To fix this problem, you should use the $set
operator instead:

	> db.newCollection.update({ name: 'Jason Krol' }, { $set: { website: 'http://jasonkrol.com'} })

There may be a time when you want to update a document, but the document itself may or may
not exist. What happens when the document does not exist, and you'd like a new one to be
created instantly based on the updated values you provide? Well, there's a handy function just for
that. Pass {upsert: true} as the third parameter to the update() function:

> db.newCollection.update({ name: 'Joe Smith' }, { name: 'Joe Smith', website: 'http://google.com' }, { upsert: true })

If we have a document with a name field that matches Joe Smith, the website
field will be updated (and the name field preserved). However, if we do not have
a matching document, a new one will be created automatically.


Deleting data

Deleting documents works almost exactly like find(), except instead of finding and returning
results, it deletes those documents that match the search criteria:

	> db.newCollection.remove({ name: 'Jason Krol' }) 

If you want the nuclear option, you can use the drop() function, which will remove every
document in a collection:

	> db.newCollection.drop()


Additional resources

For additional learning with JavaScript, I suggest you check out some of the following resources:

	* Mozilla Developer Network at https://developer.mozilla.org/en-US/docs/Web/JavaScript
	* Secrets of the JavaScript Ninja, John Resig, Bear Bibeault, Manning
	* Learning JavaScript Design Patterns, Addy Osmani, O'Reilly
	* JavaScript: The Good Parts, Douglas Crockford, O'Reilly

The Node API online documentation is going to be your best bet for fully understanding
everything that's available within the Node core set of modules. The Node API docs can be
found at http://nodejs.org/api.

Additionally, there is a great website that teaches Node using actual programming problems that
you must solve. The emphasis with these exercises is to understand the nuts and bolts of how
Node works and get down into the fundamentals of working with streams, asynchronous I/O,
promises, and more. Node school can be found at http://nodeschool.io.

Finally, the creators of MongoDB offer an amazing 7-8 week online training and certification
program completely free of charge, where you will learn everything you need to be a true
MongoDB master. This can be found at MongoDB University at
https://university.mongodb.com.

Now it's time to dive in and start writing some real code!


Summary

In this chapter, you took a crash course on the basics of JavaScript, Node.js, and MongoDB. In
addition, you learned about Node's package manager, npm. For further learning, additional
resources were provided for JavaScript, Node.js, and MongoDB.

In the next chapter, you will write your first Node web server using Express.js and get started
with creating a complete web application.