Storing UTF-8 Encoded Text with Strings

We talked about strings in Chapter 4, but we'll look at them in more depth now. New Rustaceans
commonly get stuck on strings for a combination of three reasons: Rust's propensity for exposing 
possible errors, strings being a more complicated data structure than many programmers given them
credit for, and UTF-8. These factors combine in a way that can seem difficult when you're coming
from other programming languages.

It's useful to discuss strings in the context of collections because strings are implemented as a
collection of bytes, plus some methods to provide useful functionality when those bytes are
interpreted as text. In this section, we'll talk about the operations on String that every collection
type has, such as creating, updating, and reading. We'll also discuss the ways in which String is
different from the other collections, namely how indexing into a String is complicated by the 
differences between how people and computers interpret String data.


What Is a String?

We'll first defined what we means by the term string. Rust has only one string type in the core
language, which is the string slice str that is usually seen in its borrowed form &str. In chapter 4,
we talked about string slices, which are references to some UTF-8 encoded string data stored
elsewhere. String literals, for example, are stored in the program's binary and are therefore string
slices.

The String type, which is provided by Rust's standard library rahter than coded into the core
language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to
"strings" in Rust, they usually mean the String and the string slice &str types, not just one of those
types. Although this section is largely about String, both types are used heavily in Rust's standard
library, and both String and string slices are UTF-8 encoded.

Rust's standard library also includes a number of other string types, such as OsString, OsStr, 
CString, and CStr. Library crates can provide even more options for storing string data. See how
those names all end in String or Str? They refer to owned and borrowed variants, just like the
String and str types you've seen previously. These string types can store text in different
encodings or be represented in memory in a different way, for example. We won't discuss these 
other string types in this chapter; see their API documentation for more about how to use them and
when each is appropriate.


Creating a New String

Many of the same operations available with Vec<T> are available with String as well, starting with 
the new function to create a string, shown in Listing 8-11.

Listing 8-11: Creating a new, empty String
let mut s = String::new();

This line creates a new empty string called s, which we can then load data into. Often, we'll have
some initial data that we want to start the string with. For that, we use the to_string method,
which is available on any type that implements the Display trait, as string literals do. Listing 8-12
shows two examples.

Listing 8-12: Using the to_string method to create a String from a string literal
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "inital contents".to_string();


We can also use the function String::from to create a String from a string literal. The code in 
Listing 8-13 is equivalent to the code from Listing 8-12 that uses to_string.

Listing 8-13: Using the String::from function to create a String from a string literal
let s = String::from("initial contents");

Because strings are used for so many things, we can use many different generic APIs for strings,
providing us with a lot of options. Some of them can seem redundant, but they all have their place!
In this case, String::from and to_string do the some thing, so which you choose is a matter of 
style.

Remember that strings are UTF-8 encoded, so we can include any properly encoded data in them.


Updating a String


