Traits: Defining Shared Behavior

A trait tells the Rust compiler about functionality a particular type has and can share with other
types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to
specify that a generic can be any type that has certain behavior.

  Note: Traits are similar to a feature often called interfaces in other languages, although with
  some differences.


Defining a Trait

A type's behavior consists of the methods we can call on that type. Different types share the same
behavior if we can call the same methods on all of those types. Trait definitions are a way to group
method signatures together to define a set of behaviors necessary to accomplish some purpose.

For example, let's say we have multiple structs that hold various kinds and amounts of text: a 
NewsArticle struct that holds a news story filed in a particular location and a Tweet that can have 
at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or
a reply to another tweet. 

We want to make a media aggregator library that can display summaries of data the might be
stored in a NewsArticle or Tweet Instance. To do this, we need a summary from each type, and we
need to request that summary by calling a summarize method on an instance. Listing 10-12 shows 
the definition of a Summary trait that expresses this behavior.

Listing 10-12: A Summary trait that consists of the behavior provided by a summarize method
pub trait Summary {
    fn summarize(&self) -> String;
}

Here, we declare a trait using the trait keyword and then the trait's name, which is Summary in this 
case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the
types that implement this trait, which in this case is fn summarize(&self) -> String.

After the method signature, instead of providing an implementation within curly brackets, we use a
semicolon. Each type implementing this trait must provide its own custom behavior for the body of
the method. The compiler will enforce that any type that has the Summary trait will have the method
summarize defined with this signature exactly.

A trait can have multiple methods in its body: the method signatures are listed one per line and each
line ends in a semicolon.


Implementing a Trait on a Type

Now that we've defined the desired behavior using the Summary trait, we can implement it on the
types in our media aggregator. Listing 10-13 shows an implementation of the Summary trait on the 
NewsArticle struct that uses the headline, the author, and the location to create the return value of
summarize. For the Tweet struct, we define summarize as the uesrname followed by the entire text
of the tweet, assuming that tweet content is already limited to 280 characters.

Listing 10-13: Implementing the Summary trait on the NewsArticle and Tweet types
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
	format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String, 
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
	format("{}: {}", self.username, self.content)
    }
}

Implementing a trait on a type is similar to implementing regular methods. The difference is that
after impl, we put the trait name that we want to implement, then use the for keyword, and then
specify the name of the type we want to implement the trait for. Within the impl block, we put the 
method signatures that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific behavior that we want
the methods of the trait to have for the particular type.

After implementing the trait, we can call the methods on instances of NewArticle and Tweet in
the same way we call regular methods, like this:

let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from("of course, as you probably already know, people"),
    reply: false,
    retweet: false,
};

println!("1 new tweet: {}", tweet.summarize());

This code prints

1 new tweet: horse_ebooks: of course, as you probably already know, people.

Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same
lib.rs in Listing 10-13, they're all in the same scope. Let's say this lib.rs is for crate we've called
aggregator and someone else wants to use our crate's functionality to implement the Summary trait
on a struct defined within their library's scope. They would need to bring the trait into their scope
first. They would do so by specifying use aggregator::Summary;, which then would enable them to 
implement Summary for their type. The Summary trait would also need to be a public trait for
another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.

One restriction to note with trait implementations is that we can implement a trait on a type only if
either the trait or the type is local to our crate. For example, we can implement standard library
traits like Display on a custom type liek Tweet as part of our aggregator crate functionality,
because the type Tweet is local to our aggregator crate. We can also implement Summary on
Vec<T> in our aggregator crate, because the trait Summary is local to our aggregator crate.

But we can't implement external traits on external types. For example, we can't implement the 
Display trait on Vec<T> within our aggregator crate, because Display and Vec<T> are defined 
in the standard library and aren't local to our aggregator crate. This restriction is part of a property
of programs called coherence, and more specifically the orphan rule, so named because the parent
type is not present. This rule ensures that other people's code can't break your code and vice versa.
Without the rule, two crates could implement the same trait for the same type, and Rust wouldn't 
know which implementation to use.


Default Implementations

Sometimes it's useful to have default behavior for some or all of the methods in a trait instead of
requiring implementations for all methods on every type. Then, as we implement the trait on a
particular type, we can keep or override each method's default behavior.

Listing 10-14 shows how to specify a defautl string for the summarize method of the Summary trait
instead of only defining the method signature, as we did in Listing 10-12.

Listing 10-14: Definition of a Summary trait with a default implementation of the summarize method
pub trait Summary {
    fn summarize(&self) -> String {
	String::from("(Read more...)")
    }
}

To use a default implementation to summarize instances of NewsArticle instead of defining a
custom implementation, we specify an empty impl block with impl Summary for NewsArticle {}.

Even though we're no longer defining the summarize method on NewsArticle directly, we've
provided a default implementation and specified that NewsArticle implements the Summary trait.
As a result, we can still call the summarize method on an instance of NewsArticle, like this:


