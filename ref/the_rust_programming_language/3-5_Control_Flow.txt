3.5. Control Flow

Deciding whether or not to run some code depending on if a condition is true and deciding on run
some code repeatedly while a condition is true are basic building blocks in most programming
languages. The most common constructs that let you control the flow of execution of Rust code are
if expression and loops.


if Expressions

An if expression allows you to branch your code depending on conditions. You provide a condition
and then state, "If this condition is met, run this block of code. If the condition is not met, do not run
this block of code."

Create a new project called branches in your projects directory to explore the if expression. In the 
src/main.rs file, input the following:

fn main() {
    let number = 3;

    if number < 5 {
	println!("condition was true");
    } else {
	println!("condition was false");
    }
}

All if expressions start with the keyword if, which is followed by a condition. In this case, the 
condition checks whether or not the variable number has a value less then 5. The block of code we
want to execute if the condition is true is placed immediately after the condition inside curly
brackets. Blocks of code associated with the conditions in if expressions are sometimes called 
arms, just like the arms in match expressions that we discussed in the "Comparing the Guess to the
Secret Number" section of Chapter 2.

Optionally, we can also inlude an else expression, which we chose to do here, to give the program
an alternative block of code to execute should the condition evaluate to false. If you don't provide an
else expression and the condition is false, the program will just skip the if block and move on to 
the next bit of code.

It's also worth nothing that the condition in this code must be a bool. If the condition isn't a bool,
we'll get an error.


Handling Multiple Conditions with else if

You can have multiple conditions by combining if and else in an else if expression. For example:

fn main() {
    let number = 6;

    if number % 4 == 0{
	println!("number is divisible by 4");
    } else if number % 3 == 0 {
	println!("number is divisible by 3");
    } else if number % 2 == 0 {
	println!("number is divisible by 2");
    } else {
	println!("number is not divisible by 4, 3, or 2");
    }
}

This program has four possible paths it can take.

Using too many else if expressions can clutter your code, so if you ahve more than one, you
might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called
match for these cases.


Using if in a let Statement

Because if is an expression, we can use it on the right side of a let statement, as in Listing 3-2.

Listing 3-2: Assigning the result of an if expression to a variable
fn main() {
    let condition = true;
    let number = if condition {
	5
    } else {
	6
    };

    println!("The value of number is: {}", number);
}

The number variable will be bound to a value based on the outcome of the if expression.

Remember that blocks of code evaluate to the last expression in them, and numbers by themselves
are also expressions. In this case, the value of the whole if expression depends on which block of
code executes. This means the values that have the potential to be results from each arm of the if 
must be the same type.


Repetition with Loops

It's often useful to execute a block of code more than once. For this task, Rust provides several loops.
A loop runs through the code inside the loop body to the end and then starts immediately back at
the beginning. To experiment with loops, let's make a new project called loops.

Rust has three kinds of loops: loop, while, and for. Let's try each one.


Repeating Code with loop

The loop keyword tells Rust to execute a block of code over and over again forever or until you
explicitly tell it to stop.

As an example, change the src/main.rs file in your loops directory to look like this:

fn main() {
    loop {
	println!("again!");
    }
}

When we run this program, we'll see again! printed over and over continuously until we stop the 
program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is
stuck in a continual loop.

Fortunately, Rust provides another, more reliable way to break out of a loop. You can place the 
break keyword within the loop to tell the program when to stop executing the loop. Recall that we
did this in the guessing game in the "Quitting After a Correct Guess" section of Chapter 2 to exti the 
program when the user won the game by guessing the correct number.


Returning Values from Loops

One of the uses of a loop is to retry an operation you know might fail, such as checking whether a 
thread has completed its job. However, you might need to pass the result of that operation to the
rest of your code. To do this, you can add the value you want returned after the break expression
you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here;

fn main() {
    let mut counter = 0;

    let result = loop {
	counter += 1;

	if counter == 10 {
	    break counter * 2;
	}
    };

    println!("The result is {}", result);
}

Before the loop, we declare a variable named counter and initialize it to 0. Then we declare a 
variable named result to hold the value returned from the loop. On every iteration of the loop, we
add 1 to the counter variable, and then check whether the counter is equal to 10. When it is, we
use the break keyword with the value counter * 2. After the loop, we use a semicolon to end the 
statement that assigns the value to result. Finally, we print the value in result, which in this case
is 20.


Conditional Loops with while

It's often useful for a program to evaluate a condition within a loop. While the codition is true, the
loop runs. When the condition ceases to be true, the program calls break, stopping the loop. This 
loop type could be implemented using a combination of loop, if, else, and break; you could try
that now in a program, if you'd like.

However, this pattern is so common that Rust has a built-in language construct for it, called a while
loop. Listing 3-3 uses while: the program loops three times, counting down each time, and then,
after the loop, it prints another message and exits.

Listing 3-3: Using a while loop to run code while a condition holds true
fn main() {
    let mut number = 3;

    while number != 0 {
	println!("{}!}, number);

	number -= 1;
    }

    println!("LIFTOFF!!!");
}

This construct eliminates a lot of nesting that would be necessary if you used loop, if, else, and 
break, and it's clearer. While a condition holds true, the code runs; otherwise, it exits the loop.


Looping Through a Collection with for

You could use the while construct to loop over the elements of a collection, such as an array. For
example, let's look at Listing 3-4.

Listing 3-4: Looping through each element of a collection using a while loop
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
	println!("The value is: {}", a[index]);

	index += 1;
    }
}

Here, the code counts up through the elements in the array. It starts at index 0, and then loops until
it reaches the final index in the array (that is, when index < 5 is no longer true). 

Tis approacha is error prone; we could cause the program to panic if the index length is
incorrect. It's also slow, because the compiler adds runtime code to perform the conditional check
on every element on every iteration through the loop.

As a more concise alternative, you can use a for loop and execute some code for each item in a 
collection. A for loop looks like the code in Listing 3-5.

Listing 3-5: Looping through each element of a collection using a for loop
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
	println!("the value is: {}", element);
    }
}

When we run this code, we'll see the some output as in Listing 3-4. More importantly, we've now
increased the sfety of the code and eliminated the chance of bugs that might result from going 
beyond the end of the array or not going for enough and missing some items.

The safety and conciseness of for loops make them the most commonly used loop construct in 
Rust. Even in situations in which you want to run some code a certain number of times, as in the 
countdown example that used a while loop in Listing 3-3, most Rustaceeans woudl use a for loop.
The way to do that would be to use a Range, which is a type provided by the standard library that 
generates all numbers in sequence starting from one number and ending before another number.

Here's what the countdown would look like using for loop and another mehtod we've not yet
talked about, rev, to reverse the range:

fn main() {
    for number in (1..4).rev() {
	println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}

