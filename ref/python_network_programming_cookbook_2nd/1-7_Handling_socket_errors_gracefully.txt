Handling socket errors gracefully

In any networking application, it is very common that one
end is trying to connect, but the other party is not
responding due to networking media failure or any other
reason. The Python socket library has an elegant method of
handing these errors via the socket.error exception. In this
recipe, a few examples are present.


How to do it...

Let us create a few try-except code blocks and put one
potential error type in each block. In order to get a user
input, the argparse module can be used. This module is more
powerful than simply parsing command-line arguments
using sys.argv. In the try-except blocks, put typical socket
operation, for example, create a socket object, connect to a
server, send data, and wait for a reply.

The following recipe illustrates the concepts in a few lines
of code.

Listing 1-7 shows socket_errors as follows:
import sys
import socket
import argparse

def main():
    # setup argument parsing
    parser = argparse.ArgumentParser(description='Socket Err of Example')
    parser.add_argument('--host', action='store', dest="host", required=False)
    parser.add_argument('--port', action='store', dest="port", type=int, required=False)
    parser.add_argument('--file', action="store", dest="file", required=False)

    given_args = parser.parse_args()
    host = given_args.host
    port = given_args.port
    filename = given_args.file

    # First try-except block -- create socket
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error as e:
        print("Error creating socket: %s" % e)
        sys.exit(1)

    # Second try-except block -- connect to given host/port
    try:
        s.connect((host, port))
    except socket.gaierror as e:
        print("Address-related error connecting to server: %s" % e)
        sys.exit(1)
    except socket.error as e:
        print("Connection error: %s" % e)
        sys.exit(1)

    # Third try-except block -- sending data
    try:
        msg = "GET %s HTTP/1.0\r\n\r\n" % filename
        s.sendall(msg.encode('utf-8'))
    except socket.error as e:
        print("Error sending data: %s" % e)
        sys.exit(1)

    while 1:
        # Fourth tr-except block -- waiting to receive data from remote host
        try:
            buf = s.recv(2048)
        except socket.error as e:
            print("Error receiving data: %s" % e)
            sys.exit(1)
        if not len(buf):
            break
        #write the received data
        sys.stdout.write(buf.decode('utf-8'))

if __name__ == '__main__':
    main()


How it works...

In python, passing command-line arguments to a script and
parsing them in the scipt can be done using the argparse
module. This is available in Python 2.7. For earlier versions
of Python, this module is available separately in Python
Package Index (PyPI). You can install this vai easy_install or pip.

In this recipe, three arguments are set up--a hostname,
port number, and filename. The usage of this script is as 
follows:

$ python3 1-7.py --host=<HOST> --port=<PORT> --file=<FILE>

In the preceding recipe, msg.encode('utf-8') encodes the message
into UTF-8, and buf.decode('utf-8') decodes the received UTF-8
format.

If you try the preceding recipe with a non-existent host, this 
script will print an address error as follows:

$ python3 1-7.py --host=www.pytgo.org --port=8080 --file=1-7.py

  Address-related error connecting to server: [Errno -3] Temporary failure in name resolution

If ther is no service on a specific port and if you try to
connect to that port, then this will throw a connection 
timeout error as follows:

$ python3 1-7.py --host=www.python.org --port=8080 --file=1-7.py 

This will return the following error since the host, 
www.python.org, is not listening on port 8080:

  Connection error: [Errno 11] Resource temporarily unavailable

However, if you send an arbitrary request as a correct
request to a correct port, the error may not be caught at the
application level. For example, running the following script
returns no error, but the HTML output tells us what's wrong 
with the script:

$ python3 1-7.py --host=www.python.org --port=80 --file=1-7.py
	
	HTTP/1.1 500 Domain Not Found
	Server: Varnish
	Retry-After: 0
	content-type: text/html
	Cache-Control: private, no-cache
	connection: keep-alive
	X-Served-By: cache-hnd18729-HND
	Content-Length: 221
	Accept-Ranges: bytes
	Date: Mon, 02 Sep 2019 06:21:55 GMT
	Via: 1.1 varnish
	Connection: close


	<html>
	<head>
	<title>Fastly error: unknown domain </title>
	</head>
	<body>
	<p>Fastly error: unknown domain: . Please check that this domain has been added to a service.</p>
	<p>Details: cache-hnd18729-HND</p></body></html>

In the preceding example, four try-except blocks have been used. 
All blocks use socket.error except for teh second block,
which use socket.gaierror. This is used for address-related 
errors. There are two other types of exceptions
--socket.herror is used for legacy C API, and if you use the 
settimeout() method in a socket, socket.timeout will be raised
when a timeout occurs on the socket.

