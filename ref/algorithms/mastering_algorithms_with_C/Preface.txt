Preface

When I first thought about writing this book, I immediately thought of O’Reilly &
Associates to publish it. They were the first publisher I contacted, and the one I
most wanted to work with because of their tradition of books covering “just the
facts.” This approach is not what one normally thinks of in connection with books
on data structures and algorithms. When one studies data structures and algorithms, 
normally there is a fair amount of time spent on proving their correctness
rigorously. Consequently, many books on this subject have an academic feel about
them, and real details such as implementation and application are left to be
resolved elsewhere. This book covers how and why certain data structures and
algorithms work, real applications that use them (including many examples), and
their implementation. Mathematical rigor appears only to the extent necessary in
explanations.

Naturally, I was very happy that O’Reilly & Associates saw value in a book that
covered this aspect of the subject. This preface contains some of the reasons I
think you will find this book valuable as well. It also covers certain aspects of the
code in the book, defines a few conventions, and gratefully acknowledges the
people who played a part in the book’s creation.


Organization

This book is divided into three parts. The first part consists of introductory material 
that is useful when working in the rest of the book. The second part presents
a number of data structures considered fundamental in the field of computer science. 
The third part presents an assortment of algorithms for solving common
problems. Each of these parts is described in more detail in the following sections, 
including a summary of the chapters each part contains.

Part I

Part I, Preliminaries, contains Chapters 1 through 4. Chapter 1, Introduction, introduces 
the concepts of data structures and algorithms and presents reasons for
using them. It also presents a few topics in software engineering, which are
applied throughout the rest of the book. Chapter 2, Pointer Manipulation, discusses 
a number of topics on pointers. Pointers appear a great deal in this book,
so this chapter serves as a refresher on the subject. Chapter 3, Recursion, covers
recursion, a popular technique used with many data structures and algorithms.
Chapter 4, Analysis of Algorithms, presents the analysis of algorithms. The techniques 
in this chapter are used to analyze algorithms throughout the book.

Part II

Part II, Data Structures, contains Chapters 5 through 11. Chapter 5, Linked Lists,
presents various forms of linked lists, including singly-linked lists, doubly-linked
lists, and circular lists. Chapter 6, Stacks and Queues, presents stacks and queues,
data structures for sorting and returning data on a last-in, first-out and first-in, 
firstout order respectively. Chapter 7, Sets, presents sets and the fundamental mathematics 
describing sets. Chapter 8, Hash Tables, presents chained and openaddressed 
hash tables, including material on how to select a good hash function
and how to resolve collisions. Chapter 9, Trees, presents binary and AVL trees.
Chapter 9 also discusses various methods of tree traversal. Chapter 10, Heaps and
Priority Queues, presents heaps and priority queues, data structures that help to
quickly determine the largest or smallest element in a set of data. Chapter 11,
Graphs, presents graphs and two fundamental algorithms from which many graph
algorithms are derived: breadth-first and depth-first search.

Part III

Part III, Algorithms, contains Chapters 12 through 17. Chapter 12, Sorting and
Searching, covers various algorithms for sorting, including insertion sort, quicksort, 
merge sort, counting sort, and radix sort. Chapter 12 also presents binary
search. Chapter 13, Numerical Methods, covers numerical methods, including algorithms 
for polynomial interpolation, least-squares estimation, and the solution of
equations using Newton’s method. Chapter 14, Data Compression, presents algorithms 
for data compression, including Huffman coding and LZ77. Chapter 15,
Data Encryption, discusses algorithms for DES and RSA encryption. Chapter 16,
Graph Algorithms, covers graph algorithms, including Prim’s algorithm for minimum 
spanning trees, Dijkstra’s algorithm for shortest paths, and an algorithm for
solving the traveling-salesman problem. Chapter 17, Geometric Algorithms, presents 
geometric algorithms, including methods for testing whether line segments
intersect, computing convex hulls, and computing arc lengths on spherical surfaces.