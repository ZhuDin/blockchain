-Python3 模块

模块是一个包含所有自定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用python标准库的方法。

--import语句
想使用Python源文件，只需要在另一个源文件里执行import语句，语法如下：
import module1[, module2[, ... moduleN]
当解释器遇到import语句，如果模块在当前的搜索路径应付被导入。
搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块support，需要把命令放在脚本的顶端。

一个模块只会被导入一次，不管执行了多少次import。这样可以防止导入模块被一遍又一遍执行。
Python解释器在寻找文件时会涉及到Python的搜索路径，搜索路径是一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。
也可以通过定义环境变量的方式来确定搜索路径。
搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量。在交互式解释器中，输入以下代码可以查看：
import sys
sys.path

sys.paht输出是一个列表，其中第一项是空串，代表当前目录，亦即我们执行python解释器的目录(对于脚本的话就是运行脚本所在的目录)。
因此在当前目录下存在与要引入模块同名的文件，应付把要引入的模块屏蔽掉。
了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。

--from...import语句
Python的from语句可以从模块中导入一个指定的部分到当前命名空间中，语法如下：
from modname import name1[, name2[, ... nameN]]
这个声明不会把整个模块导入到当前的命名空间串，它只会将模块里的函数引入。

--from...import * 语句
把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
from modname import *
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多使用。

--深入模块
模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次导入时才会被执行。
每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。
所以模块的作者可以放心在模块内部使用这些全局变量，而不用担心与其它用户的全局变量搞混。
从另一个方面，作者可以通过modname.itername这样的表示法来访问模块内的函数。
模块是可以导入其它模块的。在一个模块(或者脚本，或者其它地方)的最前面使用import来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。
还有一种导入的方法，可以使用import直接把模块内(函数，变量的)名称导入到当前操作模块。
这种导入的方法不会把被导入的模块的名称放在当前的字符表中。
当然也可以把模块中的所有(函数，变量)名称都导入到当前的模块的字符表。
这将把所有的名字都导入进来，但是那些由单一下划线(_)开头的名字不在此例。Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。

__name__属性
一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使用该程序块仅在该模块自身运行时执行。
说明：每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。

--dir()函数
内置的函数dir()可以找到模块内定义的所有名称。以一个字符串列表的形式返回。
如果没有给定参数，那么dir()函数会罗列出当前定义的所有名称。

--标准模块
Python本身带着一些标准的模块库，在Python库参考文档中将会介绍到。
有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。
这些组件会根据不同的操作系统进行不同形式的配置，比如winreg这个模块就只会提供给Windows系统。
应该注意到这有一个特别的模块sys，它内置在每一个Python解析器中，变量sys.ps1和sys.ps2定义了主提示符和副提示符所对应的字符串。

--包
包是一种管理Python模块命名空间的形式，采用"点模块名称"。
比如一个模块的名称是A.B，那么它表示一个包A中的子模块B。
在导入一个包的时候，Python会根据sys.path中的目录来寻找这个包中包含的子目录。
目录只有包含一个叫做__init__.py的文件才会被认作是一个包，主要是为了避免影响搜索路径中的有效模块。
最简单的情况，放一个空的:file:__init__.py就可以。当然这个文件中也可以包含一些初始化代码或者为__all__变量赋值。
用户可以每次只导入一个包里面的特定模块。

--从一个包中导入*


