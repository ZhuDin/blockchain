7. Input and Output

There are several ways to present the output of a program; data can be printed in a human-readable form, or 
written to a file for future use. This chapter will  discuss some of the possibilities.


7.1. Fancier Output Formatting

So far we've encountered two ways of writing values: expression statements and the print() function. (A third
way is using the write() mehtod of file objects; the standard output file can be referenced as sys.stdout.
See the Library Reference for more information on this.)

Often you'll want more control over the formatting of your output than simply printing space-separated values.
There are several ways to format output.

  * To use formatted string literals, begin a string with f or F before the opening quotation mark or triple
    quotation mark. Inside this string, you can write a Python expression between { and } characters that can
    refer to variables or literal values.

  * The str.format() method of strings requires more manual effort. You'll still use { and } to mark where a
    variable will be substituted and can provide detailed formatting directives, but you'll also need to provide 
    the information to be formatted.

  * Finally, you can do all the string handling yourself by using string slicing and concatenation operations to
    create any layout you can imagine. The string type has some methods that perform useful operations for
    padding strings to a given column width.

When you don't need fancy output but just want a quick display of some variables for debugging purposes, you
can convert any value to a string with the repr() or str() functions.

The str() function is meant to return representations of values which are fairly human-readable, while repr() is
meant to generate representations which can be read by the interpreter (or will force a SyntaxError if there is no
equivalent syntax). For objects which don't have a particular representation for human consumption, str() will
return the same value as repr(). Many values, such as numbers or structures like lists and dictionaries, ahve the 
same representation using either function. Strings, in particular, have two distinct representations.

The string module contains a Template class that offers yet another way to substitute values into strings, using 
placeholders like $x and replacing them with values from a dictionary, but offers much less control of the 
formatting.


7.1.1. Formatted String Literals

Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a 
string by prefixing the string with f or F and writing expressions as {expression}.

An optional format specifier can follow the expression. This allows greater control over how the value is formatted.


7.1.2. The String format() Method

Basic usage of the str.format() method looks like this:
print('We are the {} who say "{}!"'.format('knights', 'Ni'))

The brackets and characters within them (called format fields) are replaced with the objects passed into the 
str.format() method. A number in the brackets acn be used to refer to the position of the object passed into the 
str.format() method.

If keyword arguments are used in the str.format() method, their values are referred to by using the name of the 
argument.


7.1.3. Manual String Formatting

The str.rjust() method of string objects right-justifies a string in a field of a given width by padding it with 
spaces on the left. There are similar methods str.ljust() and str.center(). These methods do not write anythibg,
they just return a new string. If the input string is too long, they don't truncate it, but return it unchanged; 
this will mess up your column lay-out but that's usually better than the alternative, which would be lying about
a value.

There is another method, str.zfill(), which pads a numeric string on the left with zeros. It understands about 
plus and minus signs.


7.1.4. Old string formatting

The % operator can also be used for string formatting. It interprets the left argument much like a sprintf() -style 
format string to be applied to the right argument, and returns the string resulting from this formatting operation.


7.2. Reading and Writing Files

open() returns a file object, nd is most commonly used with two arguments:  open(filename, mode).

The first argument is a string containing the filename. The second argument is another string containg a few 
characters describing the way in which the file will be used. Mode can be 'r' when the file will only be read, 
'w' for only writing (an exiting file with the same name will be erased), and 'a' opens the file for appending; 
any data written to the file is automatically added to the end. 'r+' opens the file for both reading and writing. 
The mode argument is optional; 'r' will be assumed if it's ommitted.

Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are 
encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see open()).
'b' appended to the mode opens the file in binary mode: now the dat is read and written in the form of bytes objects. 
This mode should be used for all files that don't contain text.

In text mode, the default when reading is to convert platform-specific line endings (\n on Unix, \r\n on Windows) 
to just \n. When writing in text mode, the defult is to convert occurrences of \n back to platform-specific line 
endings. This behind-the-secnes modification to file data is fine for text files, but will corrupt binary data like 
that in JPEG or EXE files. Be very careful to use binary mode when reading and writing usch files.

It is good practice to use the with keyword when dealing with file objects. The advantage is that the file is 
properly closed after its suite finishes, even if an exception is raised at some point. Using with is also much
shorter than writing equivalent try-finally blocks.

If you're not using the with keyword, then you should call f.close() to close the file and immediately free up any
system resources used by it. If you don't explicitly close a file, Python' garbage collector will eventually destory
the object and close the open file for you, but the file may stay open for a while. Another risk is that different
Python implementations will do this clean-up at different times.


7.2.1. Methods of File Objects

The rest of the examples in this section will assume that a file object called f has already been created.

To read a file's contents, call f.read(size), which reads some quantity of data and returns it as a string (in text 
mode) or bytes object (in binary mode). size is an optional numeric argument. When size is ommitted or  negative, 
the entire contents of the file will be read and returned; it's your problem if the file is twice as large as your 
machine's memory. Otherwise, at most size bytes are read and returned. It the end of the file has been reached, 
f.read() will return an empty string('').

f.readline() raeds a single line from the file; a newline character(\n) is left at the end of the string, and is only 
omitted on the last line of the file if the file doesn't end in a newline. This makes the return value unambiguous; if 
f.eadline() returns an empty string,  the end of the file has been reached, while a blank line is represented by '\m', 
a string containing only a single newline.


7.2.2 Saving structured data with json

Strings can easily be written to and read from a file. Numbers take a bit more effort, since the read() method 
only returns strings, which will have to be passed to a function like int(), which takes a string like '123' and
returns its numeric value 123. When you want to save more conplex data types like nested lists and dictionaries, 
parsing and seralizing by hand becomes complicated.

Rather than having users constantly writing and debugging code to save complicated data types to files, Python 
allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard 
module called json can take Python data hierarchies, and convert them to string representations; this process is 
called serializing. Reconstructing the data from the string representation is called deserializing. Between 
serializing and deserializing, the string representing the object may have been stored in a file or data, or sent
over a network connection to some distant machine.

Another variant of the dumps() function, called dump(), simply serializes the object to a text file. So if f is a text 
file object opened for writing, we can do this: json.dump(x, f)

To decode the object again, if f is a text file object which has been opened for reading: x = json.load(f)


