9. Classes

Classes provide a means of bunding data and functionality together. Creating a new class creates a new type of 
object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for
maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.

Compared with other programming languages, Python's class mechanism adds classes with a minimum of new 
syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes 
provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows 
mutiple base classes, a derived class can override any methods of its base class or classes, and a method can 
call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As 
is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be 
modified further after creation.


9.1. A Word About Names and Objects

Objects have individuality, and multiple name (in multiple scopes) can be bound to the same object. This is 
known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be 
safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a 
possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, 
and most other types. This is usually used to the benefit of the programs, since aliases behave like pointers in 
some respects.


9.2. Python Scopes and Namespaces

Before introducing classes, I first have to tell you something about Python's scope rules. Class definitions play 
some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what's 
going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer.

A namespace is a mapping from names to objects. Most namespaces are currently implememted as Python dirctionaries, 
but that's normally not noticeable in any way (except for performance), and it may change in the future. 
Examples of namespace are: the set of built-in names (containing functions such as abs(), and built-in exception 
names); the global names in a module; and the local names in a function invocation. In a sense the set of 
attributes of an object also form a namespace. The important thing to know about namespaces is that there is 
absolutely no relation between names in different namespaces; for instance, two different modules may both define 
a function maximize without confusion -- users of the modules must prefix it with the module name.


9.3. A First Look at Classes

Classes introduce a little bit of new syntax, three new object types, and some new semantics.


9.3.1. Class Definition Syntax

The simplest form of class definition looks like this:

class ClassName:
    <statement-1>
    . 
    .
    .
    <statement-N>

Class definitions, like function definitions (def statements) must be executed before they have any effect. (You 
could conceivably place a class definition ina branch of an if statement, or inside a function.)

In practice, the statements inside a class definition will usually be function definitions, but other stateents are 
allowed, and sometimes useful -- we'll come back to this later. The function definitions inside a class normally have
a peculiar form of argument list, dicated by the calling conventions for methods -- again, this is explained later.

When a class definition is entered, a new namespace is created, and used as the local scope -- thus, all assignments 
to local variables go into this new namespace. In particular, function definitions bind the name of the new function
here.

When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around 
the contents of the namespace created by the class definition; we'll learn more about class objects in the next 
section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and 
the class object is bound here to the class name given in the class definition header (ClassName in the example).


9.3.2. Class Objects

Class objects support two kinds of operations: attribute references and instantiation.

Attribute references use the standard syntax used for all attribute references in Python:obj.name. Valid attribute 
names are all the names that were in the class's namespace when the class object was created.


9.3.3. Instance Objects


9.3.4. Method Objects


9.3.5. Class and Instance Variables


9.4. Random Remarks

Data attributes override method attributes with the same name; to avoid accidental name conflicts, which may cause 
hard-to-find bugs in large programs, it is wise to use some kind of convention that minimizes the chance of 
conflicts. Possible conventions include capitalizing method name, prefixing data attribute names with a small 
unique string (perhaps just an underscore), or using verbs for methods and nouns for data attributes.

Data attribute may be referenced by methods as well as by ordinary users ("clients") of an object. In other words, 
classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to
enforce data hiding -- it is all based upon convention. (On the other hand, the Python implementation, written 
in C, can completely hide implementation details and control access to an object if necessary; this can be used 
by extensions to Python written in C.)

Clients should use data attributes with care -- clients may mess up invariants maintained by the methods by stamping 
on their data attributes. Note that clients may add data attributes of their own to an instance object without
affecting the validity of the methods, as long as name conflicts are avoided -- again, a naming convention can save 
a lot of headaches here.

There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this 
actually increases the readability of methods: there is no chance of confusing local variables and instance variables 
when glancing through a method.

Often, the first argument of a method is called self. This is nothing more than a convention: the name self has 
absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less 
readable to other Python programmers, and it is also conceivable that a class browser program might be written 
that relies upon such a convention.


9.5. Inheritance 

Of course, a language feature would not be worthy of the name "class" without supporting inheritance. The 
syntax for a derived class definition looks like this:

class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>

The name BaseCalssName must be defined in a scope containing the derived class definition. In place of a base
class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class
is defined in another module:

class DerivedClassName(modname.BaseClassName):

Execution of a derived class definition proceeds the same as for a base class. When the class object is
constructed, the base class is remembered. This is used for resolving attribute references: if a requested
attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if
the base class itself is derived from some other class.

There's nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the
class. Method references are resolved as follows: the corresponding class attribute is searched, descending
down the chain of base classes if necessary, and the mehtod reference is valid if this yields a function object.

Derived classes may override methods of their base classes. Because methods have no special privileges when
calling other mehtods of the same object, a method of a base class that calls another method defined in the
same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all
mehtods in Python are effectively virtual.)

An overriding method in a derived class may in fact want to extend rather than simply replace the base class
method of the same name. There is a simple way to call the base class method directly: just call
BaseClassName.methodname(self, arguments). This is occasionally useful to clients as well. (Note that this only
works if the base class is accessible as BaseClassName in the global scope.)

Python has two built-in functions that work with inheritance:
 
  * Use isinstance() to check an instance's type: isinstance(obj, int) will be True only if obj.__class__ is
    int or some class derived from int.
  * Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of
    int. However, issubclass(float, int) is False since float is not a subclass of int.


9.5.1. Multiple Inheritance

Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like
this:

class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>

For most pruposes, in the simplest cases, you can think of the search for attributes inherited from a parent class
as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus,
if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively) in the base classes
of Base1, and if it was not found there, it was searched for in Base2, and so on.

In fact, it is slightly more complex than that; the method resolution order thcnages dynamically to support
cooperative calls to supper(). This approach is known in some other multiple-inheritance languages as call-next-mehtod
and is more powerful than the super call found in single-inheritance languages.

Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond
relationships (where at least one of the paretn classes can be accessed through multiple paths from the
bottommost class). For example, all calsses inherit from object, so any case of multiple inheritance provides 
more than one path to reach object. To keep the base classes from being accessed more than once, the
dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each
class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without
affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable
and extensible classes with multiple inheritance.


9.6. Private Variables

"Private" instance variables that cannot be accessed except from inside an object don't exist in Python. However,
there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam)
should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should
be considered an implementation detail and subject to change without notice.

Since there is a valid use-case for class-private members (namely to avoid name clashes of anmes with anmes
defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of
the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with
_classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is 
done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class.

Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls.


9.7. Odds and Ends

Sometimes it is useful to have a data type similar to the Pascal "record" or C "struct", bundling together a few
named data items. An empty class definition will do nicely.

A piece of Python code that expects a particular abstract data type can often be passed a class that emulates
the methods of that data type instead.


9.8. Iterators

By now you have probably noticed that most container objects can be looped over using a for statement.

This style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python. Behind
the scenes, the for statment calls iter() on the container object. The function returns an iterator object that
defines the method __next__() which accesses elements in the container one at a time. When there are no more
elements, __next__() raises a StopIteration exception which tells the for loop to terminate. You can call the
__next__() method using the next() built-in function.


9.9. Generators

Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use
the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes
where it left off (it remembers all the data values and which statement was last executed).


9.10. Generator Expressions

Some simple generators can be coded succinctly as expressions using a syntax similar to list comprehensions
but with parentheses instead of square brackets. These expressions are designed for situations where the 
generator is used right away by an enclosing function.

